## 模块化模式
模块化模式最初被定义为一种对传统软件工程中的类提供私有和公共封装的方法。
在JavaScript中，模块化模式用来进一步模拟类的概念，通过这一种方式：我们可以在一个单一的对象中包含公共或私有的方法和变量，从而从全局范围中屏蔽特定的部分。
这个结果可以减少函数命名与页面中其他脚本定义的函数名称冲突的可能性。

### 私有信息
模块模式使用闭包的方式来将“私有信息”状态和组织解构封装起来。提供了一种将公有和私有方法，变量封装混合在一起的方式，这种方式防止内部信息泄露到全局中，从而避免了和其它开发者接口发生冲图的可能性。在这种模式下只有公有的API 会返回，其它将全部保留在闭包的私有空间中。
这种方法提供了一个比较清晰的解决方案，在只暴露一个接口供其他部分使用的情况下，将内部执行逻辑保护起来。这个模式非常类似于立即调用函数表达式([IIFE](https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE)),但是这种模式返回的是对象，而立即调用函数表达式返回的是一个函数。
需要注意的是，在javascript事实上没有一个显式的真正意义上的"私有性"概念，因为与传统语言不同，javascript没有访问修饰符。从技术上讲，变量不能被声明为公有的或者私有的，因此我们使用函数域的方式去模拟这个概念。在模块模式中，因为闭包的缘故，声明的变量或者方法只在模块内部有效。在返回对象中定义的变量或者方法可以供任何人使用。

```javascript

const testModule = (function () {
  let counter = 0
  return {
    incrementCounter: function () {
      return ++counter
    },
    resetCounter: function () {
      counter = 0
    }
  }
})()

testModule.incrementCounter() // 1

testModule.resetCounter() // 0

```

在这里我们看到，其它部分的代码不能直接访问我们的incrementCounter() 或者 resetCounter()的值。counter变量被完全从全局域中隔离起来了，因此其表现的就像一个私有变量一样，它的存在只局限于模块的闭包内部，因此只有两个函数可以访问counter。