<!DOCTYPE html>
<html>
<head>
<title>class.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h2 id="%E7%B1%BB">类</h2>
<p>es6 引入的 class 类实质上是 JavaScript 基于原型继承的语法糖。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name;
}

Animal.prototype.sayHi = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>;
};

<span class="hljs-comment">// 等同于</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }

  sayHi() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>;
  }
}
</div></code></pre>
<p>类由两部分组成：类声明，类表达式</p>
<ol>
<li>类声明</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }
}
</div></code></pre>
<p>类实际上是个<code>特殊的函数</code>，普通函数声明和类函数声明有一个重要的区别就是函数
声明会提升，而类声明不会。如果先访问，后声明就会抛出类似于下面的错误。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal();
<span class="hljs-comment">// Uncaught ReferenceError: Cannot access 'Animal' before initialization</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}
</div></code></pre>
<ol start="2">
<li>类表达式</li>
</ol>
<p>类表达式可以是被命名的或匿名的，(ps: 类表达式也同样受到类声明中提到的提升问题的困扰。)</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 匿名类</span>
<span class="hljs-keyword">let</span> Animal = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }
};

<span class="hljs-comment">// 命名类</span>
<span class="hljs-keyword">let</span> Animal = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }

  getClassName() {
    <span class="hljs-keyword">return</span> Cat.name;
  }
};
</div></code></pre>
<p>此时类名字<code>Cat</code>只能在 class 内部使用，指代当前类，在类的外部只能用<code>Animal</code>。</p>
<ol start="3">
<li>构造函数
<code>constructor</code>方法是类的默认方法，通过<code>new</code>创建对象实例时，自动会调用该方法，
一个类必须拥有<code>constructor</code>方法，如果没有写，JavaScript 引擎会默认加上空的<code>constructor</code>方法。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}

<span class="hljs-comment">// 等同于</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {}
}
</div></code></pre>
<p><code>constructor</code>方法默认返回实例对象(既<code>this</code>),完全可以指定返回另外一个对象</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
  }
}

<span class="hljs-keyword">new</span> Animal() <span class="hljs-keyword">instanceof</span> Animal; <span class="hljs-comment">// false;</span>
</div></code></pre>
<p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Animal</code>类的实例。</p>
<ol start="4">
<li>
<p>严格模式
类和模块的内部，默认就是严格模式，比如，构造函数，静态方法，原型方法，getter 和 setter 都在严格模式下执行。</p>
</li>
<li>
<p>类的实例
类的实例，通过 new 创建, 创建时会自动调用构造函数</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }

  sayHi() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"My name is "</span> + <span class="hljs-keyword">this</span>.name;
  }
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">"rudy"</span>);
animal.sayHi(); <span class="hljs-comment">// My name is rudy</span>
</div></code></pre>
<ol start="6">
<li>存取器
与 ES5 一样，在类的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存取
函数和取值函数，拦截该属性的存取行为。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }

  get name() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"rudy"</span>;
  }

  set name(value) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"setter, "</span> + <span class="hljs-keyword">this</span>.value);
  }
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">"rudy"</span>);
animal.name = <span class="hljs-string">"Tom"</span>; <span class="hljs-comment">// setter, Tom</span>
<span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// rudy</span>
</div></code></pre>
<ol start="7">
<li>静态方法
使用<code>static</code>修饰符修饰的方法称为静态，它们不需要实例化，直接通过类来调用。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">static</span> sayHi(name) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"i am "</span> + name);
  }
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal();
Animal.sayHi(<span class="hljs-string">"rudy"</span>); <span class="hljs-comment">// i am rudy</span>
animal.sayHi(<span class="hljs-string">"rudy"</span>); <span class="hljs-comment">// Uncaught TypeError: animal.sayHi is not a function</span>
</div></code></pre>
<ol start="8">
<li>实例属性，静态属性
ES6 中的实例属性只能通过构造函数中的<code>this.xxx</code>来定义，但最近 ES7 中可以直接在类里面定义：</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  name = <span class="hljs-string">"rudy"</span>;
  <span class="hljs-keyword">static</span> value = <span class="hljs-number">11</span>;
  sayHi() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`hello, <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>);
  }
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal();
animal.sayHi(); <span class="hljs-comment">// hello, rudy</span>
Animal.value; <span class="hljs-comment">// 11</span>
animal.value; <span class="hljs-comment">// undefiend</span>
</div></code></pre>
<ol start="9">
<li>类的继承
使用<code>extends</code>关键字实现继承，子类中使用<code>super</code>关键字来调用父类的构造函数和方法。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }

  sayHi() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"this is "</span> + <span class="hljs-keyword">this</span>.name;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name, value) {
    <span class="hljs-keyword">super</span>(name); <span class="hljs-comment">// 调用父类的 constructor(name)</span>
    <span class="hljs-keyword">this</span>.value = value;
  }

  sayHi() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`omg, <span class="hljs-subst">${<span class="hljs-keyword">super</span>.sayHi()}</span> it is <span class="hljs-subst">${<span class="hljs-keyword">this</span>.value}</span>`</span>;
  }
}

<span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">11</span>);
cat.sayHi(); <span class="hljs-comment">// omg, this is Tom it is 11;</span>
</div></code></pre>
<ol start="10">
<li>super 关键字
<code>super</code>这个关键字，既可以当着函数使用，也可以当着对象使用。两种情况下，用法完全不同。</li>
</ol>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，字类的构造函数必须执行一次<code>super</code>函数。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
  }
}
</div></code></pre>
<p>上面代码中，子类<code>Cat</code>的构造函数中的<code>super()</code>，代表调用父类的构造函数，这是必须的，否在 JavaScript 引擎会报错。
注意，<code>super</code>虽然代表了父类<code>Animal</code>的构造函数，但是返回的是字类<code>Cat</code>的实例，既<code>super</code>内部的<code>this</code>指的是<code>Cat</code>的实例，因此<code>super()</code>在这里相当于
<code>Animal.prototype.constructor.call(this)</code>。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span>.target.name); <span class="hljs-comment">// new.target指向当前正在执行的函数</span>
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
  }
}

<span class="hljs-keyword">new</span> Animal(); <span class="hljs-comment">// Animal;</span>
<span class="hljs-keyword">new</span> Cat(); <span class="hljs-comment">// Cat;</span>
</div></code></pre>
<p>可以看出，在<code>super()</code>执行时，它指向的是子类<code>Cat</code>的构造函数，而不是父类<code>Animal</code>的构造函数，也就是说<code>super</code>内部的<code>this</code>指向是<code>Cat</code>。</p>
<p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  hi() {
    <span class="hljs-keyword">super</span>(); <span class="hljs-comment">// Uncaught SyntaxError: 'super' keyword unexpected here</span>
  }
}
</div></code></pre>
<p>第二种情况，<code>super</code>作为对象时:</p>
<blockquote>
<ol>
<li>在普通方法中，指向父类的原型对象，</li>
<li>在静态方法中，指向父类。</li>
</ol>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  getName() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"rudy"</span>;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">super</span>.getName());
  }
}

<span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(); <span class="hljs-comment">// rudy;</span>
</div></code></pre>
<p>上面代码中，子类<code>Cat</code>中的<code>super.getName()</code>,就是将<code>super</code>当作一个对象使用，这时，<code>super</code>在普通方法中，指向的是<code>Animal.prototype</code>，<code>super.getName()</code>相当于<code>Animal.prototype.getName()</code>。</p>
<p>这里需要注意，由于<code>super</code>指向的是父类原型对象，所以定义在父类实例上的方法和属性，是无法通过<code>super</code>获取到的。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"rudy"</span>;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
  }
  getName() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.name;
  }
}

<span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat();
cat.getName(); <span class="hljs-comment">// undefined;</span>
</div></code></pre>
<p>上面代码中，<code>name</code>是父类实例的属性，而不是父类原型对象的属性，所以<code>super.name</code>引用不到它。</p>
<p>用在静态方法中，<code>super</code>将指向父类，而不是父类的原型对象。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">static</span> getName(name) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"static"</span>, name);
  }

  getName(name) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"instance"</span>, name);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
  }

  <span class="hljs-keyword">static</span> getName(name) {
    <span class="hljs-keyword">super</span>.getName(name);
  }

  getName(name) {
    <span class="hljs-keyword">super</span>.getName(name);
  }
}

Cat.getName(<span class="hljs-string">"rudy"</span>); <span class="hljs-comment">// static rudy;</span>

<span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat();
cat.getName(<span class="hljs-string">"tom"</span>); <span class="hljs-comment">// instance tom;</span>
</div></code></pre>
<p>在上面代码中，<code>super</code>在静态方法中指向父类，在普通方法中指向父类的原型对象。</p>
<p>另外，在字类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类实例。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"rudy"</span>;
  }

  <span class="hljs-keyword">static</span> print() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.name = <span class="hljs-number">2</span>;
  }

  <span class="hljs-keyword">static</span> print() {
    <span class="hljs-keyword">super</span>.print();
  }
}

Cat.name = <span class="hljs-string">"Tom"</span>;
Cat.print(); <span class="hljs-comment">// Tom;</span>
</div></code></pre>
<h3 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h3>
<blockquote></blockquote>
<ol>
<li><a href="https://www.cnblogs.com/rubylouvre/archive/2010/03/09/1681222.html">主要参考的是司徒正美老师的文章，ps文章已经很老了，有些问题但并为修复</a></li>
<li><a href="https://juejin.im/post/5b0cf331f265da0905017b48#comment">主要引用的是后面的实例问题，但答案是我自己写的</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/ae5bf541(v=vs.100)">对正则API的引用</a></li>
</ol>

</body>
</html>
