<!-- ##知识体系

### JavaScript 基础 -->

<!-- ### 一、 变量和类型 -->

## 内存

1. 内存模型
   JS 内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。

2. 基础数据类型与栈内存
   JS 中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问,
   数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。
   基础数据类型： `Number` `String` `Null` `Undefined` `Boolean` `Symbol` `BigInt`
   要简单理解栈内存空间的存储方式，我们可以通过类比乒乓球盒子来分析。

   | 乒乓球盒子 |
   | :--------: |
   |     5      |
   |     4      |
   |     3      |
   |     2      |
   |     1      |


    这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。

3.  引用数据类型与堆内存
    与其他语言不同，JS 的引用数据类型，比如数组 `Array`，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JS 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，**我们可以粗浅地理解为保存在栈内存中的一个地址**，该地址与堆内存的实际值相关联。
    堆存取数据的方式，则与书架与书非常相似。
    书虽然也有序的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在 `JSON` 格式的数据中，我们存储的 `key-value` 是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。
    为了更好的搞懂栈内存与堆内存，我们可以结合以下例子与图解进行理解。

    ```javascript
    var a1 = 0; // 栈
    var a2 = "this is string"; // 栈
    var a3 = null; // 栈
    var b = { m: 20 }; // 变量 b 存在于栈中，{m: 20} 作为对象存在于堆内存中
    var c = [1, 2, 3]; // 变量 c 存在于栈中，[1, 2, 3] 作为对象存在于堆内存中
    ```

    因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。
    理解了 JS 的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。
    在前端面试中我们常常会遇到这样一个类似的题目

    ```javascript
    // demo01.js
    var a = 20;
    var b = a;
    b = 30;
    // 这时a的值是多少？

    // demo02.js
    var m = { a: 10, b: 20 };
    var n = m;
    n.a = 15;
    // 这时m.a的值是多少

    // demo03.js
    var m = { a: 10, b: 20 };
    var n = m;
    m = 20;
    // 这时n的值是多少
    ```

    demo1.js
    在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个内存地址。`var b = a` 执行之后，`a` 与 `b` 虽然值都等于 20，但是二者已是独立的堆内存地址，所以修改任意一个，都不会影响到另外一个。具体如图。

    [修改前]

    | 栈  | 堆  | 常量区 |
    | :-: | :-: | :----: |
    |  a  |     |   20   |
    |  b  |     |   20   |

    [修改后]
    
    | 栈  | 堆  | 常量区 |
    | :-: | :-: | :----: |
    |  a  |     |   20   |
    |  b  |     |   30   |

    此时的`a`为 20， `b`为 30;

    demo2.js
    在 demo02 中，我们通过`var n = m`执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们栈内存相互独立，但是在堆内存中访问到的具体对象实际上是同一个。所以你修改一个变量的属性，最终是会修改到同一个堆内存的对象。

    [修改前]

    |       栈        |       堆       | 常量区 |
    | :-------------: | :------------: | :----: |
    | m,n (指针地址 ) | {a: 10, b: 20} |        |

    [修改后]

    |       栈        |       堆       | 常量区 |
    | :-------------: | :------------: | :----: |
    | m,n (指针地址 ) | {a: 15, b: 20} |        |

    此时的`m.a`为 15;

    demo3.js
    在 demo3 与 demo2 只有最后`m`赋值的区别，demo3 中执行`m = 20`，实际是给 `m` 重新分配内存地址，把之前的地址指针给断开了，不在指向之前的内存地址了。

    [修改前]

    |       栈        |       堆       | 常量区 |
    | :-------------: | :------------: | :----: |
    | n,m (指针地址 ) | {a: 10, b: 20} |        |

    [修改后]

    |      栈       |       堆       | 常量区 |
    | :-----------: | :------------: | :----: |
    | n (指针地址 ) | {a: 10, b: 20} |        |
    |       m       |                |   20   |


    此时的`n`为 `{a: 10}`, `m`为 20;

## 内存的生命周期

JS环境中分配的内存一般有如下生命周期：

1. 内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存。

## 内存回收
JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。
在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此 a = null 其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。


- 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。


- 以Google的V8引擎为例，在V8引擎中所有的JAVASCRIPT对象都是通过堆来进行内存分配的。当我们在代码中声明变量并赋值时，V8引擎就会在堆内存中分配一部分给这个变量。如果已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止（默认情况下，V8引擎的堆内存的大小上限在64位系统中为1464MB，在32位系统中则为732MB）。


- 另外，V8引擎对堆内存中的JAVASCRIPT对象进行分代管理。新生代：新生代即存活周期较短的JAVASCRIPT对象，如临时变量、字符串等；
老生代：老生代则为经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

### 垃圾回收算法

#### 引用计数算法
引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。

由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。

```javascript

function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1; 

    return "Cycle reference!"
}

cycle();

```

上面我们申明了一个cycle方程，其中包含两个相互引用的对象。在调用函数结束后，对象o1和o2实际上已离开函数范围，因此不再需要了。但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了。
正是因为有这个严重的缺点，这个算法在现代浏览器中已经被下面要介绍的标记清除算法所取代了。

#### 标记清除算法

上面说过，现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。
标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。
从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。

### 参考

[JavaScript 内存机制（前端同学进阶必备）](https://juejin.im/post/5b10ba336fb9a01e66164346)