<!-- ##知识体系

### JavaScript 基础 -->

<!-- ### 一、 变量和类型 -->

## 内存

1. 内存模型
   JS 内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。

2. 基础数据类型与栈内存
   JS 中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问,
   数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。
   基础数据类型： `Number` `String` `Null` `Undefined` `Boolean` `Symbol` `BigInt`
   要简单理解栈内存空间的存储方式，我们可以通过类比乒乓球盒子来分析。

   | 乒乓球盒子 |
   | :--------: |
   |     5      |
   |     4      |
   |     3      |
   |     2      |
   |     1      |


    这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。

3.  引用数据类型与堆内存
    与其他语言不同，JS 的引用数据类型，比如数组 `Array`，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JS 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，**我们可以粗浅地理解为保存在栈内存中的一个地址**，该地址与堆内存的实际值相关联。
    堆存取数据的方式，则与书架与书非常相似。
    书虽然也有序的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在 `JSON` 格式的数据中，我们存储的 `key-value` 是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。
    为了更好的搞懂栈内存与堆内存，我们可以结合以下例子与图解进行理解。

    ```javascript
    var a1 = 0; // 栈
    var a2 = "this is string"; // 栈
    var a3 = null; // 栈
    var b = { m: 20 }; // 变量 b 存在于栈中，{m: 20} 作为对象存在于堆内存中
    var c = [1, 2, 3]; // 变量 c 存在于栈中，[1, 2, 3] 作为对象存在于堆内存中
    ```

    因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。
    理解了 JS 的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。
    在前端面试中我们常常会遇到这样一个类似的题目

    ```javascript
    // demo01.js
    var a = 20;
    var b = a;
    b = 30;
    // 这时a的值是多少？

    // demo02.js
    var m = { a: 10, b: 20 };
    var n = m;
    n.a = 15;
    // 这时m.a的值是多少

    // demo03.js
    var m = { a: 10, b: 20 };
    var n = m;
    m = 20;
    // 这时n的值是多少
    ```

    demo1.js
    在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个内存地址。`var b = a` 执行之后，`a` 与 `b` 虽然值都等于 20，但是二者已是独立的堆内存地址，所以修改任意一个，都不会影响到另外一个。具体如图。
    [修改前]
    
    | 栈 | 堆 | 常量区 |
    | :-: | :-: | :----: |
    | a | | 20 |
    | b | | 20 |

    [修改后]

    | 栈 | 堆 | 常量区 |
    | :-: | :-: | :----: |
    | a | | 20 |
    | b | | 30 |
    此时的`a`为 20， `b`为 30;

    demo2.js
    在 demo02 中，我们通过`var n = m`执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们栈内存相互独立，但是在堆内存中访问到的具体对象实际上是同一个。所以你修改一个变量的属性，最终是会修改到同一个堆内存的对象。
    [修改前]

    | 栈 | 堆 | 常量区 |
    | :-------------: | :------------: | :----: |
    | m,n (指针地址 ) | {a: 10, b: 20} | |

    [修改后]

    | 栈 | 堆 | 常量区 |
    | :-------------: | :------------: | :----: |
    | m,n (指针地址 ) | {a: 15, b: 20} | |
    此时的`m.a`为 15;

    demo3.js
    在 demo3 与 demo2 只有最后`m`赋值的区别，demo3 中执行`m = 20`，实际是给 `m` 重新分配内存地址，把之前的地址指针给断开了，不在指向之前的内存地址了。
    [修改前]

    | 栈 | 堆 | 常量区 |
    | :-------------: | :------------: | :----: |
    | n,m (指针地址 ) | {a: 10, b: 20} | |

    [修改后]

    | 栈 | 堆 | 常量区 |
    | :-------------: | :------------: | :----: |
    | n (指针地址 ) | {a: 10, b: 20} | |
    | m | | 20 |


    此时的`n`为 `{a: 10}`, `m`为 20;
