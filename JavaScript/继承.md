# Javascript 常见的六种继承方式。

## 原型链继承

这种方式关键在于：**子类型的原型为父类型的一个实例对象**

```javascript
// 父类型
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.doc = [];
  this.getName = function () {};
}

Person.prototype.getAge = function () {};

// 子类型
function Student(price) {
  this.price = price;
  this.getNums = function () {};
}

Student.prototype = new Person(); // 子类型的原型为父类型的实例对象

var s1 = new Student(100);
var s2 = new Student(200);
```

这种方式实现的本质是把子类的原型指向了父类的实例，因此**子类的实例是可以通过**proto**去访问 Student.prototype 也就是父类 Person 的实例，这样就可以访问到父类的私有方法和属性，如果想再要访问 Person 的私有方法，就可以把**proto**指向父类 Person.prototype 就可以获取到父类原型上的方法(即 Person 的私有方法)**。于是做到了将父类的私有、共有方法和属性都当作子类的共有属性。

**子类继承父类的属性和方法是将父类的私有属性和共有方法都作为自己的共有属性和方法**。如果父类的私有属性是引用类型的属性，那么它被子类继承后作为共有属性，当子类在操作这个属性时候，就会影响到其他的子类。

```javascript
function Person(name, age) {
  (this.name = name), (this.age = age);
}
Person.prototype.setAge = function () {
  console.log("111");
};
function Student(price) {
  this.price = price;
  this.setScore = function () {};
}
// Student.prototype.sayHello = function () { }//在这里写子类的原型方法和属性是无效的，
//因为会改变原型的指向，所以应该放到重新指定之后
Student.prototype = new Person();
Student.prototype.sayHello = function () {};
var s1 = new Student(15000);
console.log(s1);
```

### 特点：

- 父类新增原型方法/原型属性，子类都能访问到
- 简单，易于实现

### 缺点：

- 无法实现多继承
- 来自原型对象的所有属性被所有实例共享
- 创建子类实例时，无法向父类构造函数传参
- 要想为子类新增属性和方法，必须要在 Student.prototype = new Person() 之后执行，不能放到构造器中

https://segmentfault.com/a/1190000016708006
