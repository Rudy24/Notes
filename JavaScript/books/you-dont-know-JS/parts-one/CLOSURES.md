## 作用域闭包 #

什么是闭包呢？下面是直接了当的定义：
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数实在当前词法作用域之外执行。

下面用些代码来解释这个定义。

```javascript

function foo () {
  var a = 2;
  function bar () {
    console.log(a); // 2
  }

  bar ();
}

foo();

```

这是闭包吗？
技术上来讲，也许是，但根据前面的定义，确切的说并不是，我认为最准确地用来解释
`bar()` 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是`闭包`的一部分（但却是最重要的一部分）

再来看看下面的代码，清晰地展示了闭包：

```javascript

function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();

baz(); // 这就是闭包的效果

```

函数 `bar()` 的词法作用域能够访问 `foo()`的内部作用域，然后将`bar()`函数本身当作一个值类型进行传递。
在`foo()`执行后，其返回值(也就是内部的`bar()`函数) 赋值给变量`baz`并调用 `baz()`,实际上只是通过不同的标识符引用调用了内部的函数`bar()`。

`bar()`显然可以被正常执行，在这个例子中，它在自己定义的词法作用域以外的地方执行。在`foo()`执行后，引擎的垃圾回收机制不会对其内存空间进行释放，
`bar()`依然持有对该作用域的引用，而这个引用就叫做闭包。